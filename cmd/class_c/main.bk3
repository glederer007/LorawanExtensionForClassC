package main1

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
        "crypto/tls"
        "io/ioutil"
        "bytes"
        "github.com/brocaar/lorawan"
	"encoding/hex"
//	"encoding/base64"
//	"net/url"
)

type ApiGetNodeSessionResponse struct {
	DevAddr string `json:"devAddr"`
	AppEUI string `json:"appEUI"`
	DevEUI string `json:"devEUI"`
	AppSKey string `json:"appSKey"`
	NwkSKey string `json:"nwkSKey"`
	FCntUp uint32 `json:"fCntUp"`
	FCntDown uint32 `json:"fCntDown"`
	RxDelay int `json:"rxDelay"`
	Rx1DROffset int `json:"rx1DROffset"`
	CFList []int `json:"cFList"`
	RxWindow string `json:"rxWindow"`
	Rx2DR int `json:"rx2DR"`
	RelaxFCnt bool `json:"relaxFCnt"`
	AdrInterval int `json:"adrInterval"`
	InstallationMargin int `json:"installationMargin"`
	NbTrans int `json:"nbTrans"`
	TxPower int `json:"txPower"`
}

type ApiGetNodes struct {
	Result []struct {
		AdrInterval int `json:"adrInterval"`
		AppEUI string `json:"appEUI"`
		AppKey string `json:"appKey"`
		ChannelListID string `json:"channelListID"`
		DevEUI string `json:"devEUI"`
		InstallationMargin int `json:"installationMargin"`
		Name string `json:"name"`
		RelaxFCnt bool `json:"relaxFCnt"`
		Rx1DROffset int `json:"rx1DROffset"`
		Rx2DR int `json:"rx2DR"`
		RxDelay int `json:"rxDelay"`
		RxWindow string `json:"rxWindow"`
	} `json:"result"`
	TotalCount string `json:"totalCount"`
}

type Numverify struct {
	Valid               bool   `json:"valid"`
	Number              string `json:"number"`
	LocalFormat         string `json:"local_format"`
	InternationalFormat string `json:"international_format"`
	CountryPrefix       string `json:"country_prefix"`
	CountryCode         string `json:"country_code"`
	CountryName         string `json:"country_name"`
	Location            string `json:"location"`
	Carrier             string `json:"carrier"`
	LineType            string `json:"line_type"`
}

func main() {
//	phone := "14158586273"
	// QueryEscape escapes the phone string so
	// it can be safely placed inside a URL query
//	safePhone := url.QueryEscape(phone)

//	url := fmt.Sprintf("http://apilayer.net/api/validate?access_key=9b75300c32361eea06386651934121c6&number=%s", safePhone)
url := fmt.Sprintf("https://192.168.0.100:8888/api/nodeSession/0004A30B001B4530")

	// Build the request
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal("NewRequest: ", err)
		return
	}

  tr := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }


	// For control over HTTP client headers,
	// redirect policy, and other settings,
	// create a Client
	// A Client is an HTTP client



	client := &http.Client{Transport: tr}

	// Send the request via a client
	// Do sends an HTTP request and
	// returns an HTTP response
	resp, err := client.Do(req)
	if err != nil {
		log.Fatal("Do: ", err)
		return
	}

	// Callers should close resp.Body
	// when done reading from it
	// Defer the closing of the body
	defer resp.Body.Close()

	// Fill the record with the data from the JSON
	//var record Numverify
        
        var record ApiGetNodeSessionResponse

	// Use json.Decode for reading streams of JSON data
	if err := json.NewDecoder(resp.Body).Decode(&record); err != nil {
		log.Println(err)
	}

	fmt.Println("devAddr = ", record.DevAddr)
	fmt.Println("devEUI  = ", record.DevEUI)
	fmt.Println("fCntDown= ", record.FCntDown )
        record.FCntDown = record.FCntDown +1
        fmt.Println("fCntDown= ", record.FCntDown )

	b, err := json.Marshal(record)
	if err != nil {
		fmt.Println("error:", err)
	}

    
	
	fmt.Println(string(b))


url = fmt.Sprintf("https://192.168.0.100:8888/api/nodeSession/0004A30B001B4530")

//    var jsonStr = []byte(`{"title":"Buy cheese and bread for breakfast."}`)
    req, err = http.NewRequest("PUT", url, bytes.NewBuffer(b))
    req.Header.Set("Content-Type", "application/json")
    req.Header.Set("Accept", "application/json")

    client = &http.Client{Transport: tr}

	resp, err = client.Do(req)
	if err != nil {
		log.Fatal("Do: ", err)
		return
	}

    defer resp.Body.Close()

    fmt.Println("response Status:", resp.Status)
    fmt.Println("response Headers:", resp.Header)
    body, _ := ioutil.ReadAll(resp.Body)
    fmt.Println("response Body:", string(body))


//	fmt.Println("Carrier   = ", record.Carrier)
//	fmt.Println("LineType  = ", record.LineType)
        fmt.Println("Resp.Body  = ", resp.Body)

var nwkSKey1,appSKey1 [16]byte
var devAddr1 [4]byte
nwkSKey2,_ := hex.DecodeString(record.NwkSKey)
appSKey2,_ := hex.DecodeString(record.AppSKey)
devAddr2,_ := hex.DecodeString(record.DevAddr)


copy(nwkSKey1[:], nwkSKey2[0:16])
copy(appSKey1[:], appSKey2[0:16])
copy(devAddr1[:], devAddr2[0:4])


//fmt.Println("nwks1: ",nwkSKey1)

//nwkSKey := [16]byte{111, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
//appSKey := [16]byte{161, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
fPort := uint8(10)


//fmt.Println("nwks0: ",nwkSKey)


phy := lorawan.PHYPayload{
    MHDR: lorawan.MHDR{
        MType: lorawan.UnconfirmedDataDown,
        Major: lorawan.LoRaWANR1,
    },
    MACPayload: &lorawan.MACPayload{
        FHDR: lorawan.FHDR{
            DevAddr: lorawan.DevAddr(devAddr1),
            FCtrl: lorawan.FCtrl{
                ADR:       false,
                ADRACKReq: false,
                ACK:       false,
            },
            FCnt:  record.FCntDown,
            FOpts: []lorawan.MACCommand{}, // you can leave this out when there is no MAC command to send
        },
        FPort:      &fPort,
        FRMPayload: []lorawan.Payload{&lorawan.DataPayload{Bytes: []byte{1, 2, 3, 4}}},
    },
}

if err := phy.EncryptFRMPayload(appSKey1); err != nil {
    panic(err)
}

if err := phy.SetMIC(nwkSKey1); err != nil {
    panic(err)
}

str, err := phy.MarshalText()
if err != nil {
    panic(err)
}

bytes, err := phy.MarshalBinary()
if err != nil {
    panic(err)
}

fmt.Println(string(str))
fmt.Println(bytes)


}

