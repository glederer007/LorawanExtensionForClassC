package main

import "fmt"
import "github.com/brocaar/lorawan"
//import "log"
import "net/http"
//import "encoding/json"
import "crypto/tls"
//  import "net/url"


func main() {

type ApiGetNodeSessionResponse struct {
adrInterval string `json:"adrInterval"`
appEUI string `json:"appEUI"`
appSKey string `json:"appSKey"`
cFList string `json:"cFList"`
devAddr string `json:"devAddr"`
devEUI string `json:"devEUI"`
fCntDown string `json:"fCntDown"`
fCntUp string `json:"fCntUp"`
installationMargin string `json:"installationMargin"`
nbTrans string `json:"nbTrans"`
nwkSKey string `json:"nwkSKey"`
relaxFCnt string `json:"relaxFCnt"`
rx1DROffset string `json:"rx1DROffset"`
rx2DR string `json:"rx2DR"`
rxDelay string `json:"rxDelay"`
rxWindow string `json:"rxWindow"`
txPower string `json:"txpower"`
}

type ApiGetNodes struct {
	Result []struct {
		AdrInterval int `json:"adrInterval"`
		AppEUI string `json:"appEUI"`
		AppKey string `json:"appKey"`
		ChannelListID string `json:"channelListID"`
		DevEUI string `json:"devEUI"`
		InstallationMargin int `json:"installationMargin"`
		Name string `json:"name"`
		RelaxFCnt bool `json:"relaxFCnt"`
		Rx1DROffset int `json:"rx1DROffset"`
		Rx2DR int `json:"rx2DR"`
		RxDelay int `json:"rxDelay"`
		RxWindow string `json:"rxWindow"`
	} `json:"result"`
	TotalCount string `json:"totalCount"`
}

url := fmt.Sprintf("https://192.168.0.100:8888/api/nodeSession/0004A30B001A1DAD")
//url := fmt.Sprintf("https://192.168.0.100:8888/api/node")

  tr := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    client := &http.Client{Transport: tr}

    reply, err := client.Get(url)
    if err != nil {
        fmt.Println(err)
    }
//req, err := http.NewRequest("GET", url, nil)
//        if err != nil {
//                log.Fatal("NewRequest: ", err)
//                return
//        }

//client := &http.Client{}

//resp, err := client.Do(req)
//	if err != nil {
//		log.Fatal("Do: ", err)
//		return
//	}
//defer resp.Body.Close()
    

var record ApiGetNodeSessionResponse

	// Use json.Decode for reading streams of JSON data
//	if err := json.NewDecoder(resp.Body).Decode(&record); err != nil {
//		log.Println(err)
//	}

fmt.Println("devEUI ", record.devEUI)
fmt.Println("resp", reply )

nwkSKey := [16]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
appSKey := [16]byte{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
fPort := uint8(10)

phy := lorawan.PHYPayload{
    MHDR: lorawan.MHDR{
        MType: lorawan.ConfirmedDataUp,
        Major: lorawan.LoRaWANR1,
    },
    MACPayload: &lorawan.MACPayload{
        FHDR: lorawan.FHDR{
            DevAddr: lorawan.DevAddr([4]byte{1, 2, 3, 4}),
            FCtrl: lorawan.FCtrl{
                ADR:       false,
                ADRACKReq: false,
                ACK:       false,
            },
            FCnt:  0,
            FOpts: []lorawan.MACCommand{}, // you can leave this out when there is no MAC command to send
        },
        FPort:      &fPort,
        FRMPayload: []lorawan.Payload{&lorawan.DataPayload{Bytes: []byte{1, 2, 3, 4}}},
    },
}

if err := phy.EncryptFRMPayload(appSKey); err != nil {
    panic(err)
}

if err := phy.SetMIC(nwkSKey); err != nil {
    panic(err)
}

str, err := phy.MarshalText()
if err != nil {
    panic(err)
}

bytes, err := phy.MarshalBinary()
if err != nil {
    panic(err)
}

fmt.Println(string(str))
fmt.Println(bytes)
}
