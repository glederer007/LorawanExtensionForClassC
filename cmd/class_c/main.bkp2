package main

import "fmt"
import "github.com/brocaar/lorawan"
import "log"
import "net/http"
import "encoding/json"
import "crypto/tls"
import "net/url"


func main() {

type ApiGetNodeSessionResponse struct {
adrInterval string `json:"adrInterval"`
appEUI string `json:"appEUI"`
appSKey string `json:"appSKey"`
cFList string `json:"cFList"`
devAddr string `json:"devAddr"`
devEUI string `json:"devEUI"`
fCntDown string `json:"fCntDown"`
fCntUp string `json:"fCntUp"`
installationMargin string `json:"installationMargin"`
nbTrans string `json:"nbTrans"`
nwkSKey string `json:"nwkSKey"`
relaxFCnt string `json:"relaxFCnt"`
rx1DROffset string `json:"rx1DROffset"`
rx2DR string `json:"rx2DR"`
rxDelay string `json:"rxDelay"`
rxWindow string `json:"rxWindow"`
txPower string `json:"txpower"`
}

type Numverify struct {
	Valid               bool   `json:"valid"`
	Number              string `json:"number"`
	LocalFormat         string `json:"local_format"`
	InternationalFormat string `json:"international_format"`
	CountryPrefix       string `json:"country_prefix"`
	CountryCode         string `json:"country_code"`
	CountryName         string `json:"country_name"`
	Location            string `json:"location"`
	Carrier             string `json:"carrier"`
	LineType            string `json:"line_type"`
}

type ApiGetNodes struct {
	Result []struct {
		AdrInterval int `json:"adrInterval"`
		AppEUI string `json:"appEUI"`
		AppKey string `json:"appKey"`
		ChannelListID string `json:"channelListID"`
		DevEUI string `json:"devEUI"`
		InstallationMargin int `json:"installationMargin"`
		Name string `json:"name"`
		RelaxFCnt bool `json:"relaxFCnt"`
		Rx1DROffset int `json:"rx1DROffset"`
		Rx2DR int `json:"rx2DR"`
		RxDelay int `json:"rxDelay"`
		RxWindow string `json:"rxWindow"`
	} `json:"result"`
	TotalCount string `json:"totalCount"`
}

	phone := "14158586273"
	// QueryEscape escapes the phone string so
	// it can be safely placed inside a URL query
	safePhone := url.QueryEscape(phone)

	url := fmt.Sprintf("http://apilayer.net/api/validate?access_key=YOUR_ACCESS_KEY&number=%s", safePhone)

//url := fmt.Sprintf("https://192.168.0.100:8888/api/nodeSession/0004A30B001A1DAD")
//url := fmt.Sprintf("https://192.168.0.100:8888/api/node?limit=20")

  tr := &http.Transport{
        TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
    }
    client := &http.Client{Transport: tr}

//    reply, err := client.Get(url)
//    if err != nil {
//        fmt.Println(err)
//    }

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		log.Fatal("NewRequest: ", err)
		return
	}
	
        resp, err := client.Do(req)
	if err != nil {
		log.Fatal("Do: ", err)
		return
	} 

        defer resp.Body.Close()

//var record ApiGetNodeSessionResponse
var record Numverify

	// Use json.Decode for reading streams of JSON data
	if err := json.NewDecoder(resp.Body).Decode(&record); err != nil {
		log.Println(err)
	}

//fmt.Println("valami ", record.fCntUp)
fmt.Println("resp", resp.Body)
fmt.Println("Phone No. = ", record.InternationalFormat)

nwkSKey := [16]byte{1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}
appSKey := [16]byte{16, 15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1}
fPort := uint8(10)

phy := lorawan.PHYPayload{
    MHDR: lorawan.MHDR{
        MType: lorawan.ConfirmedDataUp,
        Major: lorawan.LoRaWANR1,
    },
    MACPayload: &lorawan.MACPayload{
        FHDR: lorawan.FHDR{
            DevAddr: lorawan.DevAddr([4]byte{1, 2, 3, 4}),
            FCtrl: lorawan.FCtrl{
                ADR:       false,
                ADRACKReq: false,
                ACK:       false,
            },
            FCnt:  0,
            FOpts: []lorawan.MACCommand{}, // you can leave this out when there is no MAC command to send
        },
        FPort:      &fPort,
        FRMPayload: []lorawan.Payload{&lorawan.DataPayload{Bytes: []byte{1, 2, 3, 4}}},
    },
}

if err := phy.EncryptFRMPayload(appSKey); err != nil {
    panic(err)
}

if err := phy.SetMIC(nwkSKey); err != nil {
    panic(err)
}

str, err := phy.MarshalText()
if err != nil {
    panic(err)
}

bytes, err := phy.MarshalBinary()
if err != nil {
    panic(err)
}

fmt.Println(string(str))
fmt.Println(bytes)
}
